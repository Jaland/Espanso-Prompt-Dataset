#!/usr/bin/env python3
"""
Script to generate main-base.yaml from all individual prompt files.
This script combines all YAML files in the prompts directory into a single file.
"""

import os
import yaml
from pathlib import Path
import sys


def multiline_string_representer(dumper, data):
    """Custom YAML representer for multiline strings."""
    if '\n' in data:
        return dumper.represent_scalar('tag:yaml.org,2002:str', data, style='|')
    return dumper.represent_scalar('tag:yaml.org,2002:str', data)


# Register the custom representer
yaml.add_representer(str, multiline_string_representer)


def load_yaml_file(file_path):
    """Load a YAML file and return its content."""
    try:
        with open(file_path, 'r', encoding='utf-8') as file:
            content = yaml.safe_load(file)
            return content
    except Exception as e:
        print(f"Error loading {file_path}: {e}")
        return None


def find_prompt_files(prompts_dir):
    """Find all YAML files in the prompts directory."""
    prompt_files = []
    for root, dirs, files in os.walk(prompts_dir):
        for file in files:
            if file.endswith('.yaml') or file.endswith('.yml'):
                prompt_files.append(os.path.join(root, file))
    return sorted(prompt_files)


def generate_main_config(prompts_dir, output_file):
    """Generate the main configuration file from all prompt files."""
    prompt_files = find_prompt_files(prompts_dir)
    
    if not prompt_files:
        print("No prompt files found!")
        return False
    
    # Initialize the main config structure
    main_config = {
        'matches': []
    }
    
    # Add header comment
    header_comment = f"""# Auto-generated main configuration file
# This file is automatically generated from all prompt files in the prompts/ directory
# Do not edit this file directly - edit the individual prompt files instead
# 
# Generated from {len(prompt_files)} prompt files:"""
    
    for file_path in prompt_files:
        relative_path = os.path.relpath(file_path, os.path.dirname(output_file))
        header_comment += f"\n# - {relative_path}"
    
    # Process each prompt file
    for file_path in prompt_files:
        print(f"Processing: {file_path}")
        content = load_yaml_file(file_path)
        
        if content and 'matches' in content:
            # Add a comment section for each file
            relative_path = os.path.relpath(file_path, os.path.dirname(output_file))
            section_comment = f"\n# === Prompts from {relative_path} ===\n"
            
            # Add all matches from this file
            main_config['matches'].extend(content['matches'])
    
    # Write the combined configuration
    try:
        with open(output_file, 'w', encoding='utf-8') as file:
            # Write header comment
            for line in header_comment.split('\n'):
                file.write(f"{line}\n")
            file.write("\n")
            
            # Write the YAML content with better formatting for multiline strings
            yaml.dump(main_config, file, 
                     default_flow_style=False, 
                     sort_keys=False, 
                     allow_unicode=True,
                     width=1000)  # Prevent line wrapping
        
        print(f"Successfully generated {output_file} with {len(main_config['matches'])} prompts")
        return True
        
    except Exception as e:
        print(f"Error writing {output_file}: {e}")
        return False


def main():
    """Main function."""
    script_dir = Path(__file__).parent
    repo_root = script_dir.parent
    prompts_dir = repo_root / 'prompts'
    output_file = repo_root / 'main-base.yaml'
    
    print("Espanso Prompt Generator")
    print(f"Repository root: {repo_root}")
    print(f"Prompts directory: {prompts_dir}")
    print(f"Output file: {output_file}")
    print("-" * 50)
    
    if not prompts_dir.exists():
        print(f"Error: Prompts directory {prompts_dir} does not exist!")
        sys.exit(1)
    
    success = generate_main_config(str(prompts_dir), str(output_file))
    
    if success:
        print("✅ Main configuration file generated successfully!")
        sys.exit(0)
    else:
        print("❌ Failed to generate main configuration file!")
        sys.exit(1)


if __name__ == "__main__":
    main()
